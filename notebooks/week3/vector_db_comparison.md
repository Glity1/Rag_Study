## Week3 벡터 DB 비교 노트

### 1. 후보 엔진 개요
- **FAISS (Meta)**  
  - 장점: 단일 머신에서 매우 빠른 근사 최근접 탐색(IVF, HNSW 등), 오픈소스.  
  - 단점: 기본 버전은 메모리 기반, 운영 기능 부족.  
  - 권장: 연구/프로토타이핑, 온프레미스 환경.
- **Chroma**  
  - 장점: 파이썬 친화적, RAG 워크플로에 특화된 API, 메타데이터 필터 지원.  
  - 단점: 대규모 분산 환경 지원은 제한적.  
  - 권장: 소규모/중간 규모 프로젝트, 빠른 실험.
- **Milvus**  
  - 장점: 분산 확장, 다양한 인덱스, 클라우드 네이티브.  
  - 단점: 운영 복잡도, 초기 설정 부담.  
  - 권장: 대규모 서비스, 클러스터 기반 운영.
- **Weaviate**  
  - 장점: 하이브리드 검색 내장, GraphQL/REST/GRPC API, SaaS 제공.  
  - 단점: 러닝 커브, 비용 고려 필요.  
  - 권장: 하이브리드 검색, 빠른 프로덕션 전환.

### 2. 비교 기준
- **데이터 규모**: 문서 수가 10만 건 이상이면 분산형 엔진(Milvus/Weaviate) 고려.  
- **검색 기능**: 메타데이터 필터, 하이브리드 BM25+벡터 검색 여부.  
- **배포 환경**: 로컬/온프레미스 vs 클라우드/SaaS.  
- **운영 편의성**: 모니터링, 백업, 업데이트 난이도.  
- **커뮤니티 & 생태계**: 문서/예제, LangChain 통합 여부.

### 3. 선택 가이드
1. **학습/실습**: Chroma 또는 FAISS in-memory.  
2. **중간 규모 PoC**: Milvus Standalone, Weaviate Cloud, Chroma + 외부 스토리지.  
3. **프로덕션 대규모**: Milvus 클러스터, Weaviate 클라우드/온프레미스, Qdrant 클러스터.  
4. **특수 요구**: 하이브리드 검색이 필수라면 Weaviate/Qdrant, 규제 환경이면 자체 호스팅 FAISS+Elasticsearch 조합.

### 4. 파이프라인 반영
- **임베딩 파이프라인**: `embedding_pipeline.py`에서 문서 → 벡터, 메타데이터 구성.  
- **저장 단계**: 선택한 벡터 DB SDK/클라이언트로 upsert.  
- **검색 단계**: Retriever 구현 시 SDK 호출로 top-k 문서 조회.  
- **재랭킹 옵션**: 필요 시 Cross-Encoder 혹은 rerank API 연동.

### 5. 향후 실습 아이디어
- 동일한 질의 세트를 여러 DB에 질의해 결과 비교.  
- 하이브리드 검색 결과와 단일 벡터 검색 결과 비교.  
- 인덱스 파라미터(예: IVF nprobe, HNSW ef) 조절 실험.  
- Latency/Recall 측정 스크립트 작성.


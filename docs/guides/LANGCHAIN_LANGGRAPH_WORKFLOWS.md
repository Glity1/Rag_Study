# LangChain & LangGraph 일반적인 작업 흐름 순서도

이 문서는 LangChain과 LangGraph의 일반적인 작업 흐름을 순서도로 설명합니다.

---

## 📋 목차

1. [LangChain 일반적인 작업 흐름](#langchain-일반적인-작업-흐름)
2. [LangGraph 일반적인 작업 흐름](#langgraph-일반적인-작업-흐름)
3. [일반적인 사용 패턴 비교](#일반적인-사용-패턴-비교)
4. [실무에서 자주 사용되는 패턴](#실무에서-자주-사용되는-패턴)

---

## LangChain 일반적인 작업 흐름

### 1. 기본 RAG 체인

```
┌─────────────────────────────────────────────────────────┐
│              LangChain 기본 RAG 흐름                      │
└─────────────────────────────────────────────────────────┘

[초기화]
    ↓
Document Loader (PDF, 웹, DB 등)
    ↓
Text Splitter (청킹)
    ↓
Embeddings (벡터화)
    ↓
Vector Store (FAISS, Pinecone, Chroma 등)
    ↓
┌─────────────────────────────────────┐
│ RetrievalQA Chain 구성              │
│ - LLM 설정                          │
│ - Retriever 설정                    │
│ - Chain 타입 선택                    │
└─────────────────────────────────────┘
    ↓
[실행]
    ↓
사용자 질문
    ↓
┌─────────────────────────────────────┐
│ chain.run(question)                 │
│                                     │
│ ① Retriever                         │
│    질문 → 임베딩 → 벡터 검색           │
│                                     │
│ ② Document Loader                   │
│    검색된 문서 로드                   │
│                                     │
│ ③ Prompt Template                   │
│    질문 + 문서 → 프롬프트 구성         │
│                                     │
│ ④ LLM                               │
│    프롬프트 → 답변 생성                │
└─────────────────────────────────────┘
    ↓
답변 반환
```

**특징:**
- 선형 흐름: 입력 → 처리 → 출력
- 블랙박스: 내부 단계 접근 어려움
- 단순: 한 번의 호출로 완료

---

### 2. Sequential Chain (체인 연결)

```
┌─────────────────────────────────────────────────────────┐
│          LangChain Sequential Chain 흐름                 │
└─────────────────────────────────────────────────────────┘

질문 입력
    ↓
┌─────────────────────────────────────┐
│ Chain 1: 질문 분류                   │
│ → "기술 질문" / "일반 질문"           │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Chain 2: 검색 전략 선택               │
│ → "벡터 검색" / "키워드 검색"          │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Chain 3: RAG 실행                    │
│ → 실제 답변 생성                      │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ Chain 4: 답변 후처리                  │
│ → 포맷팅, 검증                        │
└─────────────────────────────────────┘
    ↓
최종 답변
```

**사용 사례:**
- 복잡한 작업을 여러 단계로 분리
- 각 단계의 결과를 다음 단계로 전달
- 단계별 프롬프트 최적화 가능

---

### 3. Conversational RAG (대화형)

```
┌─────────────────────────────────────────────────────────┐
│        LangChain Conversational RAG 흐름                 │
└─────────────────────────────────────────────────────────┘

[초기화]
    ↓
ConversationBufferMemory 생성
    ↓
ConversationalRetrievalChain 구성
    ↓
[대화 시작]
    ↓
사용자 질문
    ↓
┌─────────────────────────────────────┐
│ ① 이전 대화 히스토리 로드              │
│   memory.chat_memory                │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ ② 질문 + 히스토리 → 검색용 질문 생성    │
│   (질문 재작성)                       │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ ③ Retriever                         │
│   검색용 질문 → 문서 검색              │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ ④ LLM                               │
│   질문 + 문서 + 히스토리 → 답변        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ ⑤ Memory 업데이트                    │
│   질문/답변 저장                      │
└─────────────────────────────────────┘
    ↓
답변 반환
    ↓
[다음 대화로 반복]
```

**사용 사례:**
- 챗봇 구현
- 대화 맥락 유지
- 이전 대화 참조

---

### 4. Map-Reduce Chain (대용량 문서)

```
┌─────────────────────────────────────────────────────────┐
│          LangChain Map-Reduce Chain 흐름                 │
└─────────────────────────────────────────────────────────┘

큰 문서 입력
    ↓
┌─────────────────────────────────────┐
│ 문서 분할 (Chunking)                 │
│ → 여러 작은 청크로 분할                │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ [Map 단계] - 병렬 처리                │
│                                     │
│ 청크1 → LLM → 답변1                  │
│ 청크2 → LLM → 답변2                  │
│ 청크3 → LLM → 답변3                  │
│ ...                                 │
│ 청크N → LLM → 답변N                  │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ [Reduce 단계]                       │
│                                     │
│ 모든 답변 수집                        │
│    ↓                                │
│ Combine Prompt 구성                  │
│    ↓                                │
│ LLM으로 최종 답변 생성                │
└─────────────────────────────────────┘
    ↓
통합된 최종 답변
```

**사용 사례:**
- 긴 문서 처리
- 토큰 제한 우회
- 여러 문서 통합 요약

---

## LangGraph 일반적인 작업 흐름

### 1. 기본 StateGraph 구조

```
┌─────────────────────────────────────────────────────────┐
│              LangGraph 기본 구조                         │
└─────────────────────────────────────────────────────────┘

[그래프 정의]
    ↓
┌─────────────────────────────────────┐
│ State 정의 (TypedDict)               │
│ - 입력/출력 필드 정의                  │
│ - 중간 상태 필드 정의                  │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ StateGraph 생성                      │
│ workflow = StateGraph(State)        │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 노드 추가                            │
│ workflow.add_node("node1", func1)   │
│ workflow.add_node("node2", func2)   │
│ ...                                 │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 엣지 연결                            │
│ workflow.set_entry_point("node1")   │
│ workflow.add_edge("node1", "node2") │
│ workflow.add_edge("node2", END)     │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 컴파일                               │
│ app = workflow.compile()            │
└─────────────────────────────────────┘
    ↓
[실행]
    ↓
app.invoke(initial_state)
    ↓
각 노드 순차 실행 → 상태 업데이트 → 최종 상태 반환
```

**특징:**
- 노드 기반: 각 단계가 명시적 노드
- 상태 관리: State로 중간 결과 추적
- 명시적 제어: 각 단계의 입력/출력 확인 가능

---

### 2. 조건부 분기 (Conditional Edges)

```
┌─────────────────────────────────────────────────────────┐
│        LangGraph 조건부 분기 흐름                         │
└─────────────────────────────────────────────────────────┘

[시작]
    ↓
┌─────────────────────────────────────┐
│ 노드1: 질문 분석                    │
│ → 질문 유형 판단                    │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 조건부 분기 함수                    │
│ def route(state):                   │
│   if state["type"] == "technical":  │
│       return "tech_chain"           │
│   elif state["type"] == "general":  │
│       return "general_chain"        │
│   else:                             │
│       return "default_chain"        │
└─────────────────────────────────────┘
    ↓
    ├──────────┬──────────┬──────────┐
    ↓          ↓          ↓          ↓
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│tech_chain│ │general_ │ │default_ │ │  END   │
│         │ │ chain   │ │ chain   │ │        │
└─────────┘ └─────────┘ └─────────┘ └─────────┘
    ↓          ↓          ↓
    └──────────┴──────────┘
              ↓
          최종 답변
```

**사용 사례:**
- 질문 유형별 다른 처리
- 조건에 따른 라우팅
- 동적 워크플로우

---

### 3. 루프 처리 (Cycles)

```
┌─────────────────────────────────────────────────────────┐
│            LangGraph 루프 처리 흐름                       │
└─────────────────────────────────────────────────────────┘

[시작]
    ↓
┌─────────────────────────────────────┐
│ 노드1: 검색                         │
│ → 문서 검색                         │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 노드2: 답변 생성                    │
│ → LLM으로 답변 생성                 │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 노드3: 품질 평가                    │
│ → 답변 품질 점수 계산               │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 조건부 분기                         │
│ 품질 점수 > 임계값?                 │
└─────────────────────────────────────┘
    ↓                    ↓
  (Yes)              (No)
    ↓                    ↓
┌─────────────────────────────────────┐
│ 최종 답변                           │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 질문 개선                           │
│ → 더 구체적인 질문으로 수정         │
└─────────────────────────────────────┘
    ↓
    └─────── (노드1로 돌아감) ───────┘
         (최대 반복 횟수 제한)
```

**사용 사례:**
- 답변 품질 개선
- 반복적 정제
- Self-RAG 패턴

---

### 4. 병렬 처리 (Parallel Nodes)

```
┌─────────────────────────────────────────────────────────┐
│          LangGraph 병렬 처리 흐름                         │
└─────────────────────────────────────────────────────────┘

[시작]
    ↓
질문 입력
    ↓
    ├──────────────────┬──────────────────┐
    ↓                  ↓                  ↓
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Dense 검색  │  │ Keyword 검색│  │ Hybrid 검색 │
│ 노드        │  │ 노드        │  │ 노드        │
│             │  │             │  │             │
│ (병렬 실행) │  │ (병렬 실행) │  │ (병렬 실행) │
└─────────────┘  └─────────────┘  └─────────────┘
    ↓                  ↓                  ↓
    └──────────────────┴──────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 병합 노드 (Merge)     │
        │ → 모든 결과 수집       │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 재순위화 노드         │
        │ → 결과 통합 및 정렬   │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 답변 생성 노드        │
        │ → 최종 답변 생성      │
        └───────────────────────┘
                    ↓
                최종 답변
```

**사용 사례:**
- 다중 검색 전략
- 성능 향상 (병렬 처리)
- 결과 통합

---

### 5. 에이전트 워크플로우 (Agent Pattern)

```
┌─────────────────────────────────────────────────────────┐
│          LangGraph 에이전트 워크플로우                     │
└─────────────────────────────────────────────────────────┘

[시작]
    ↓
사용자 요청
    ↓
┌─────────────────────────────────────┐
│ 노드1: 계획 수립 (Plan)             │
│ → 작업 단계 계획                    │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 노드2: 도구 선택 (Select Tool)      │
│ → 필요한 도구 결정                  │
└─────────────────────────────────────┘
    ↓
┌─────────────────────────────────────┐
│ 조건부 분기                         │
│ 어떤 도구?                          │
└─────────────────────────────────────┘
    ↓
    ├──────────┬──────────┬──────────┐
    ↓          ↓          ↓          ↓
┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
│검색 도구│ │계산 도구│ │코드 실행│ │DB 조회  │
│노드     │ │노드     │ │노드     │ │노드     │
└─────────┘ └─────────┘ └─────────┘ └─────────┘
    ↓          ↓          ↓          ↓
    └──────────┴──────────┴──────────┘
                    ↓
        ┌───────────────────────┐
        │ 결과 평가 노드        │
        │ → 목표 달성 여부 확인  │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 조건부 분기           │
        │ 목표 달성?            │
        └───────────────────────┘
            ↓              ↓
          (Yes)          (No)
            ↓              ↓
        최종 답변    (계획 노드로 돌아감)
```

**사용 사례:**
- 복잡한 작업 자동화
- 도구 사용
- ReAct 패턴

---

### 6. 복합 RAG 워크플로우 (실무 패턴)

```
┌─────────────────────────────────────────────────────────┐
│          LangGraph 고급 RAG 워크플로우                    │
└─────────────────────────────────────────────────────────┘

[시작]
    ↓
질문 입력
    ↓
┌─────────────────────────────────────┐
│ 노드1: 질문 전처리                  │
│ → 질문 정제, 확장                   │
└─────────────────────────────────────┘
    ↓
    ├──────────────────┬──────────────────┐
    ↓                  ↓                  ↓
┌─────────────┐  ┌─────────────┐  ┌─────────────┐
│ Dense 검색  │  │ Keyword 검색│  │ Graph 검색  │
│ (의미 기반) │  │ (키워드 기반)│  │ (관계 기반) │
└─────────────┘  └─────────────┘  └─────────────┘
    ↓                  ↓                  ↓
    └──────────────────┴──────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 노드2: 결과 병합      │
        │ → 모든 검색 결과 통합 │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 노드3: 재순위화       │
        │ → Cross-Encoder 사용  │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 노드4: 관련성 필터링   │
        │ → 점수 > 임계값만 유지 │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 노드5: 문서 요약       │
        │ → 긴 문서 요약        │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 노드6: 답변 생성       │
        │ → LLM으로 답변 생성    │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 노드7: 답변 검증       │
        │ → 사실 확인, 품질 평가 │
        └───────────────────────┘
                    ↓
        ┌───────────────────────┐
        │ 조건부 분기           │
        │ 검증 통과?            │
        └───────────────────────┘
            ↓              ↓
          (Yes)          (No)
            ↓              ↓
    ┌──────────────┐ ┌──────────────┐
    │ 노드8: 포맷팅│ │ 질문 개선    │
    │ → 최종 정리  │ │ → 재검색     │
    └──────────────┘ └──────────────┘
            ↓              ↓
            └─────── (노드1로) ────┘
                    ↓
        ┌───────────────────────┐
        │ 노드9: 인용 추가       │
        │ → 문서 출처 표시       │
        └───────────────────────┘
                    ↓
                최종 답변
```

**사용 사례:**
- 엔터프라이즈급 RAG 시스템
- 높은 품질 요구
- 복잡한 검색 전략

---

## 일반적인 사용 패턴 비교

### LangChain 패턴

1. **단순 체인**: A → B → C
   - 가장 기본적인 패턴
   - 순차적 처리

2. **순차 체인**: Chain1 → Chain2 → Chain3
   - 여러 체인을 연결
   - 각 체인의 결과를 다음 체인으로 전달

3. **라우터 체인**: 조건 → ChainA 또는 ChainB
   - 조건에 따라 다른 체인 실행
   - 동적 라우팅

4. **Map-Reduce**: 여러 청크 → 병렬 처리 → 병합
   - 대용량 문서 처리
   - 병렬 처리 후 통합

### LangGraph 패턴

1. **선형 그래프**: 노드1 → 노드2 → 노드3
   - 기본적인 순차 처리
   - 현재 프로젝트 Week5와 유사

2. **조건부 분기**: 노드 → 조건 → 경로A 또는 경로B
   - 동적 워크플로우
   - 상황에 따른 다른 처리

3. **루프**: 노드1 → 노드2 → 조건 → (노드1로 돌아감)
   - 반복적 개선
   - Self-RAG 패턴

4. **병렬**: 노드A, 노드B, 노드C → 병합 노드
   - 동시 처리
   - 성능 향상

5. **복합**: 위 모든 패턴 조합
   - 복잡한 워크플로우
   - 실무 시스템

---

## 실무에서 자주 사용되는 패턴

### 1. 멀티 에이전트 시스템

```
에이전트1 (검색) ──┐
에이전트2 (분석) ──┼→ 조정자 → 최종 답변
에이전트3 (검증) ──┘
```

**특징:**
- 각 에이전트가 특정 역할 담당
- 조정자가 결과 통합
- LangGraph로 구현 용이

### 2. Self-RAG 패턴

```
검색 → 생성 → 자기 평가 → (불만족 시 재검색) → 최종 답변
```

**특징:**
- 답변 품질 자동 검증
- 필요 시 자동 재검색
- 루프 구조 필요

### 3. ReAct 패턴

```
생각(Thought) → 행동(Action) → 관찰(Observation) → (반복) → 최종 답변
```

**특징:**
- 추론과 행동의 반복
- 도구 사용 가능
- 에이전트 워크플로우

### 4. 하이브리드 검색 패턴

```
질문 → [Dense 검색 + Keyword 검색] → 병합 → 재순위화 → 답변 생성
```

**특징:**
- 여러 검색 전략 조합
- 병렬 처리로 성능 향상
- 결과 통합 및 정렬

---

## 요약

### LangChain
- **단순한 선형 흐름**에 적합
- **체인 조합**으로 확장
- **빠른 프로토타이핑**에 유리
- **내부 동작 추적** 어려움

### LangGraph
- **복잡한 워크플로우**에 적합
- **조건부 분기, 루프, 병렬 처리** 지원
- **상태 추적** 용이
- **확장성** 높음

### 선택 기준
- **단순한 RAG**: LangChain
- **복잡한 워크플로우**: LangGraph
- **상태 추적 필요**: LangGraph
- **빠른 개발**: LangChain
- **프로덕션 시스템**: LangGraph

---

이 문서는 LangChain과 LangGraph의 일반적인 작업 흐름을 순서도로 설명합니다. 실제 구현 시 프로젝트 요구사항에 맞게 조정하여 사용하세요.

